meta {
  name: 12 - Password Reset & Rate Limiting
  type: http
  seq: 12
}

post {
  url: {{baseUrl}}/auth/password-reset
  body: json
  auth: none
}

headers {
  Content-Type: application/json
}

body:json {
  {
    "email": "admin@example.com"
  }
}

docs {
  ## Password Reset & Rate Limiting Tests

  Covers end-to-end password reset flow (request → token lookup → confirm → login) and rate limiting behaviour.

  **Scenarios**
  1. Initiate password reset for the seeded admin account.
  2. Retrieve the generated reset token from Postgres.
  3. Confirm the reset with a new strong password.
  4. Login using the new password and revert to the original password.
  5. Issue 4 reset requests for the same email and verify the 4th returns HTTP 429 with `Retry-After`.

  **Prerequisites**
  - Local API running at {{baseUrl}}
  - Docker Postgres service available via `docker compose exec postgres`
  - Seeded admin account: `admin@example.com / Test1234%`
}

script:post-response {
  (async function() {
    const { execSync } = require("child_process");

    function runSQL(query) {
      const command = `cd .. && PGPASSWORD=postgres docker compose exec -T postgres psql -U postgres -d postgres -At -c "${query}"`;
      try {
        return execSync(command, { stdio: ["pipe", "pipe", "pipe"], encoding: "utf8" }).trim();
      } catch (error) {
        throw new Error(`Failed to run SQL: ${error.stderr || error.message}`);
      }
    }

    const baseUrl = bru.getEnvVar("baseUrl");
    const originalPassword = "Test1234%";
    const resetPassword = "TempReset123!";

    // Test 1: Request accepted
    test("Password reset request accepted", function() {
      expect(res.getStatus()).to.equal(200);
    });

    // Fetch the latest password reset token
    const token = runSQL("SELECT token FROM auth.password_reset_tokens ORDER BY created_at DESC LIMIT 1;");

    test("Password reset token generated", function() {
      expect(token).to.be.a("string").that.is.not.empty;
    });

    // Confirm password reset with the retrieved token
    await bru.sendRequest({
      method: "POST",
      url: `${baseUrl}/auth/password-reset/confirm`,
      headers: { "Content-Type": "application/json" },
      data: {
        token: token,
        new_password: resetPassword,
        confirm_password: resetPassword
      }
    }, function(err, resetResponse) {
      if (err) {
        test("Password reset confirmation succeeds", function() {
          throw new Error(`Reset confirmation failed: ${err.message}`);
        });
        return;
      }

      test("Password reset confirmation succeeds", function() {
        expect(resetResponse.status).to.equal(200);
      });
    });

    // Login with the new password to confirm it works
    let newAccessToken = "";
    await bru.sendRequest({
      method: "POST",
      url: `${baseUrl}/auth/login`,
      headers: { "Content-Type": "application/json" },
      data: {
        email: "admin@example.com",
        password: resetPassword
      }
    }, function(err, loginResponse) {
      if (err) {
        test("Login with new password succeeds", function() {
          throw new Error(`Login failed: ${err.message}`);
        });
        return;
      }

      test("Login with new password succeeds", function() {
        expect(loginResponse.status).to.equal(200);
        expect(loginResponse.data).to.have.property("access_token");
      });

      if (loginResponse.status === 200 && loginResponse.data) {
        newAccessToken = loginResponse.data.access_token;
      }
    });

    if (newAccessToken) {
      // Revert password back to original to keep fixtures stable
      await bru.sendRequest({
        method: "POST",
        url: `${baseUrl}/auth/password`,
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${newAccessToken}`
        },
        data: {
          current_password: resetPassword,
          new_password: originalPassword,
          confirm_password: originalPassword
        }
      }, function(err, changeResponse) {
        if (err) {
          test("Revert password succeeds", function() {
            throw new Error(`Password revert failed: ${err.message}`);
          });
          return;
        }

        test("Revert password succeeds", function() {
          expect([200, 204]).to.include(changeResponse.status);
        });
      });
    } else {
      console.log("⚠️  Skipping password revert; login failed so no access token captured.");
    }

    // Rate limiting test: 4 requests within same window
    const rateLimitEmail = `ratelimit.${Date.now()}@example.com`;
    for (let attempt = 1; attempt <= 4; attempt += 1) {
      await bru.sendRequest({
        method: "POST",
        url: `${baseUrl}/auth/password-reset`,
        headers: { "Content-Type": "application/json" },
        data: {
          email: rateLimitEmail
        }
      }, function(err, response) {
        const resData = response || (err && err.response);
        if (attempt < 4) {
          if (err) {
            test(`Password reset attempt ${attempt} allowed`, function() {
              throw new Error(`Attempt ${attempt} failed: ${err.message}`);
            });
            return;
          }
          test(`Password reset attempt ${attempt} allowed`, function() {
            expect(resData.status).to.equal(200);
          });
        } else {
          test("Password reset attempt 4 blocked by rate limiter", function() {
            expect(resData.status).to.equal(429);
            expect(resData.headers).to.have.property("retry-after");
          });
        }
      });
    }
  })();
}
