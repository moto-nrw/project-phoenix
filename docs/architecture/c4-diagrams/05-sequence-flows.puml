@startuml Project Phoenix - Key Sequence Flows

' Authentication Flow
@startuml authentication-flow
title Authentication Flow - Login and Token Refresh

actor User
participant "Frontend\n(Next.js)" as Frontend
participant "NextAuth" as Auth
participant "Backend\n(Go)" as Backend
database "PostgreSQL" as DB

== Login ==
User -> Frontend: Enter email/password
Frontend -> Auth: signIn(credentials)
Auth -> Backend: POST /auth/login
Backend -> DB: Validate credentials\n(Argon2id hash)
DB --> Backend: User data + permissions
Backend -> DB: Clean up old tokens
Backend --> Auth: JWT access token (15min)\nJWT refresh token (1hr)\nUser metadata
Auth -> Auth: Store tokens in session\n(server-side only!)
Auth --> Frontend: Redirect to /dashboard
Frontend --> User: Dashboard loaded

== Auto Token Refresh (every 4 minutes) ==
Frontend -> Auth: Check token expiry
Auth -> Auth: Token expires soon?
alt Token needs refresh (1min before expiry)
    Auth -> Backend: POST /auth/refresh\n{refresh_token}
    Backend -> DB: Validate refresh token
    DB --> Backend: Token valid
    Backend --> Auth: New access token (15min)
    Auth -> Auth: Update session\nwith new token
    Auth --> Frontend: Session updated
else Token still valid
    Auth --> Frontend: No action needed
end

== API Request with Token ==
User -> Frontend: Click "View Groups"
Frontend -> Frontend: fetch("/api/groups")
note right: Next.js API Route\n(server-side)
Frontend -> Auth: auth() - get session
Auth --> Frontend: session.user.token
Frontend -> Backend: GET /api/groups\nAuthorization: Bearer {token}
Backend -> Backend: Validate JWT signature\nCheck expiry
Backend -> DB: Query groups\nCheck permissions
DB --> Backend: Group data
Backend --> Frontend: Response (snake_case, int64)
Frontend -> Frontend: Map types\n(camelCase, string)
Frontend --> User: Display groups

@enduml

' Student Check-in Flow
@startuml student-checkin-flow
title Student Check-in Flow via RFID

actor Student
participant "RFID Reader" as RFID
participant "Backend\n(Go)" as Backend
participant "SSE Hub" as SSE
database "PostgreSQL" as DB
participant "Frontend\n(Supervisor)" as Frontend

== Device Authentication ==
RFID -> Backend: POST /iot/devices/{id}/ping\nX-API-Key: {device_api_key}
Backend -> DB: Validate device API key
DB --> Backend: Device valid
Backend --> RFID: 200 OK

== Staff PIN Entry ==
RFID -> RFID: Prompt for staff PIN
note right: Staff enters 4-digit PIN
RFID -> Backend: POST /iot/checkin\n{device_id, staff_pin, rfid_tag}\nX-API-Key: {device_api_key}
Backend -> DB: Validate device API key
DB --> Backend: Device valid
Backend -> DB: Validate staff PIN\n(Argon2id hash)
DB --> Backend: Staff authenticated

== Student Check-in ==
Student -> RFID: Scan RFID card
RFID -> Backend: {rfid_tag: "ABC123"}
Backend -> DB: Find student by RFID tag
DB --> Backend: Student data
Backend -> DB: Get active session\nfor staff's group
DB --> Backend: Active session found
Backend -> DB: Create visit record\nIN active.visits
DB --> Backend: Visit created
Backend -> SSE: Broadcast event\n{type: "student_checkin",\nactive_group_id, student_id}
SSE --> Frontend: SSE event
Frontend -> Frontend: Refetch group visits\nfrom bulk endpoint
Frontend --> Frontend: Update UI\n(show student in room)
Backend --> RFID: 201 Created\n{student_name, room_name}
RFID --> Student: Display confirmation\n"Welcome, {name}!"

@enduml

' Real-Time SSE Flow
@startuml sse-realtime-flow
title Real-Time Updates via Server-Sent Events

actor Supervisor
participant "Frontend\n(MyRoom)" as Frontend
participant "SSE Proxy\n(Next.js)" as Proxy
participant "SSE Hub\n(Backend)" as Hub
participant "Backend API" as Backend
database "PostgreSQL" as DB

== Initial Page Load ==
Supervisor -> Frontend: Navigate to /myroom
Frontend -> Backend: GET /api/active/groups/mine
Backend -> DB: Get supervisor's\nactive groups
DB --> Backend: Active group data
Backend --> Frontend: Group + students list
Frontend --> Supervisor: Display room dashboard

== SSE Connection ==
Frontend -> Frontend: useSSE("/api/sse/events")
Frontend -> Proxy: EventSource("/api/sse/events")
note right: Can't set Authorization\nheader in EventSource
Proxy -> Proxy: auth() - extract JWT\nfrom session
Proxy -> Hub: Connect SSE\nAuthorization: Bearer {token}
Hub -> Hub: Register client\nSubscribe to active_group_id
Hub --> Proxy: Stream connected\nContent-Type: text/event-stream
Proxy --> Frontend: Forward event stream

== Student Check-in Event ==
note over Backend: Student checks in\nvia RFID device
Backend -> DB: Create visit record
DB --> Backend: Visit created
Backend -> Hub: Broadcast event\n{type: "student_checkin",\nactive_group_id, student_id}
Hub -> Hub: Find subscribed clients\nfor active_group_id
Hub --> Proxy: SSE event\ndata: {type, active_group_id, student_id}
Proxy --> Frontend: Forward event
Frontend -> Frontend: handleSSEEvent()
Frontend -> Backend: GET /api/active/visits?group_id={id}
note right: Refetch full data\n(event is notification only)
Backend -> DB: Query updated visit list
DB --> Backend: All active visits
Backend --> Frontend: Visit data with\nstudent details
Frontend --> Supervisor: Update UI\n(add student card)

== Connection Lost ==
Proxy -x Frontend: Network error
Frontend -> Frontend: Exponential backoff\n1s → 2s → 4s → 8s → 16s
Frontend -> Proxy: Reconnect attempt #1
alt Reconnect successful
    Proxy -> Hub: Re-establish connection
    Hub --> Proxy: Stream connected
    Proxy --> Frontend: Events resume
else Max attempts reached (5)
    Frontend --> Supervisor: Show "Disconnected" indicator\nManual refresh required
end

@enduml

' Group Creation Flow
@startuml group-creation-flow
title Group Creation with Multi-Supervisor Assignment

actor User
participant "Frontend\n(GroupForm)" as Frontend
participant "Next.js API\nRoute" as API
participant "Route Wrapper" as Wrapper
participant "Backend\n(GroupsAPI)" as Backend
participant "Service Layer" as Service
participant "Repository" as Repo
database "PostgreSQL" as DB

== Form Submission ==
User -> Frontend: Fill form\n(name, room, supervisors)
Frontend -> Frontend: Validate input\n(Zod schema)
Frontend -> API: POST /api/groups\n{name, room_id, supervisor_ids}
note right: Next.js 15:\nparams are async
API -> Wrapper: createPostHandler()\nawait context.params
Wrapper -> Wrapper: auth() - get session
Wrapper -> Wrapper: Extract JWT from\nsession.user.token
API -> Backend: POST /api/groups\nAuthorization: Bearer {token}\n{name, room_id: 123, supervisor_ids: [1,2]}
note right: Backend receives:\nsnake_case, int64

== Backend Processing ==
Backend -> Backend: Verify JWT signature\nCheck permissions\n(groups:write)
Backend -> Service: CreateGroup(ctx, request)
Service -> Service: Validate business rules:\n- Name unique?\n- Room available?\n- Supervisors exist?

== Transaction Start ==
Service -> Service: txHandler.RunInTx()
Service -> Repo: Create group entity
Repo -> DB: BEGIN TRANSACTION
Repo -> DB: INSERT INTO\neducation.groups\n(name, room_id)
DB --> Repo: Group ID = 42

Service -> Repo: Assign supervisors
loop For each supervisor_id
    Repo -> DB: INSERT INTO\nactive.group_supervisors\n(group_id, teacher_id, role)
    DB --> Repo: Supervisor assigned
end

Service -> Service: All operations OK?
alt Success
    Repo -> DB: COMMIT
    DB --> Repo: Transaction committed
else Error
    Repo -> DB: ROLLBACK
    DB --> Repo: Transaction rolled back
    Service --> Backend: Error response
end

== Response Mapping ==
Backend -> Backend: Map Group entity to\nGroupResponse DTO\n(load teachers, room)
Backend --> API: 201 Created\n{id: 42, name, room_id, supervisors}
API -> Wrapper: Map response\n(snake_case → camelCase,\nint64 → string)
Wrapper --> Frontend: {id: "42", name, roomId: "123", supervisors}
Frontend --> User: Success notification\nRedirect to group detail

@enduml

@enduml
