
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>jwt: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/moto-nrw/project-phoenix/auth/jwt/authenticator.go (65.6%)</option>
				
				<option value="file1">github.com/moto-nrw/project-phoenix/auth/jwt/claims.go (100.0%)</option>
				
				<option value="file2">github.com/moto-nrw/project-phoenix/auth/jwt/errors.go (100.0%)</option>
				
				<option value="file3">github.com/moto-nrw/project-phoenix/auth/jwt/token.go (100.0%)</option>
				
				<option value="file4">github.com/moto-nrw/project-phoenix/auth/jwt/tokenauth.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package jwt

import (
        "context"
        "net/http"

        "github.com/moto-nrw/project-phoenix/logging"

        "github.com/lestrrat-go/jwx/v2/jwt"

        "github.com/go-chi/jwtauth/v5"
        "github.com/go-chi/render"
)

type CtxKey int

const (
        CtxClaims CtxKey = iota
        CtxRefreshToken
        CtxPermissions // Context key for permissions
)

// ClaimsFromCtx retrieves the parsed AppClaims from request context.
func ClaimsFromCtx(ctx context.Context) AppClaims <span class="cov8" title="1">{
        return ctx.Value(CtxClaims).(AppClaims)
}</span>

// PermissionsFromCtx retrieves the permissions array from request context.
func PermissionsFromCtx(ctx context.Context) []string <span class="cov8" title="1">{
        perms, ok := ctx.Value(CtxPermissions).([]string)
        if !ok </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return perms</span>
}

// RefreshTokenFromCtx retrieves the parsed refresh token from context.
func RefreshTokenFromCtx(ctx context.Context) string <span class="cov8" title="1">{
        return ctx.Value(CtxRefreshToken).(string)
}</span>

// Authenticator is a default authentication middleware to enforce access from the
// Verifier middleware request context values. The Authenticator sends a 401 Unauthorized
// response for any unverified tokens and passes the good ones through.
func Authenticator(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                token, claims, err := jwtauth.FromContext(r.Context())

                if err != nil </span><span class="cov8" title="1">{
                        logging.GetLogEntry(r).Warn("JWT error:", err)
                        _ = render.Render(w, r, ErrUnauthorized(ErrTokenUnauthorized))
                        return
                }</span>

                <span class="cov8" title="1">if token == nil </span><span class="cov0" title="0">{
                        logging.GetLogEntry(r).Warn("No token found in context")
                        if renderErr := render.Render(w, r, ErrUnauthorized(ErrTokenUnauthorized)); renderErr != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">if err := jwt.Validate(token); err != nil </span><span class="cov0" title="0">{
                        logging.GetLogEntry(r).Warn("Token validation failed:", err)
                        if renderErr := render.Render(w, r, ErrUnauthorized(ErrTokenExpired)); renderErr != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // Token is authenticated, parse claims
                <span class="cov8" title="1">var c AppClaims
                err = c.ParseClaims(claims)
                if err != nil </span><span class="cov0" title="0">{
                        logging.GetLogEntry(r).Error("Failed to parse claims:", err)
                        if renderErr := render.Render(w, r, ErrUnauthorized(ErrInvalidAccessToken)); renderErr != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // Set AppClaims on context
                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), CtxClaims, c)

                // Also set permissions on context for easier access
                ctx = context.WithValue(ctx, CtxPermissions, c.Permissions)

                // Call the next handler with updated context
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// AuthenticateRefreshJWT checks validity of refresh tokens and is only used for access token refresh and logout requests. It responds with 401 Unauthorized for invalid or expired refresh tokens.
func AuthenticateRefreshJWT(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                token, claims, err := jwtauth.FromContext(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        logging.GetLogEntry(r).Warn(err)
                        if renderErr := render.Render(w, r, ErrUnauthorized(ErrTokenUnauthorized)); renderErr != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">if token == nil </span><span class="cov0" title="0">{
                        logging.GetLogEntry(r).Warn("No token found in context")
                        if renderErr := render.Render(w, r, ErrUnauthorized(ErrTokenUnauthorized)); renderErr != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">if err := jwt.Validate(token); err != nil </span><span class="cov0" title="0">{
                        if renderErr := render.Render(w, r, ErrUnauthorized(ErrTokenExpired)); renderErr != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // Parse and validate claims to ensure token integrity
                <span class="cov8" title="1">var c RefreshClaims
                err = c.ParseClaims(claims)
                if err != nil </span><span class="cov8" title="1">{
                        logging.GetLogEntry(r).Error("Failed to parse refresh token claims:", err)
                        if renderErr := render.Render(w, r, ErrUnauthorized(ErrInvalidAccessToken)); renderErr != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                // Get the raw token string from the Authorization header
                // This is needed for the auth service to look up the token in the database
                <span class="cov8" title="1">authHeader := r.Header.Get("Authorization")
                tokenString := ""
                if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov8" title="1">{
                        tokenString = authHeader[7:]
                }</span>

                // Set the token string on context (refresh claims not needed in context)
                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), CtxRefreshToken, tokenString)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package jwt

import (
        "errors"

        "github.com/lestrrat-go/jwx/v2/jwt"
)

type CommonClaims struct {
        ExpiresAt int64 `json:"exp,omitempty"`
        IssuedAt  int64 `json:"iat,omitempty"`
}

// AppClaims represent the claims parsed from JWT access token.
type AppClaims struct {
        ID          int      `json:"id,omitempty"`
        Sub         string   `json:"sub,omitempty"`
        Username    string   `json:"username,omitempty"`
        FirstName   string   `json:"first_name,omitempty"`
        LastName    string   `json:"last_name,omitempty"`
        Roles       []string `json:"roles,omitempty"`
        Permissions []string `json:"permissions,omitempty"` // Added permissions field
        // Static role flags for quick access
        IsAdmin   bool `json:"is_admin,omitempty"`
        IsTeacher bool `json:"is_teacher,omitempty"`
        CommonClaims
}

// ParseClaims parses JWT claims into AppClaims.
func (c *AppClaims) ParseClaims(claims map[string]any) error <span class="cov8" title="1">{
        id, ok := claims["id"]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("could not parse claim id")
        }</span>
        <span class="cov8" title="1">c.ID = int(id.(float64))

        sub, ok := claims[jwt.SubjectKey]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("could not parse claim sub")
        }</span>
        <span class="cov8" title="1">c.Sub = sub.(string)

        username, ok := claims["username"]
        if ok &amp;&amp; username != nil </span><span class="cov8" title="1">{
                c.Username = username.(string)
        }</span>

        <span class="cov8" title="1">firstName, ok := claims["first_name"]
        if ok &amp;&amp; firstName != nil </span><span class="cov8" title="1">{
                c.FirstName = firstName.(string)
        }</span>

        <span class="cov8" title="1">lastName, ok := claims["last_name"]
        if ok &amp;&amp; lastName != nil </span><span class="cov8" title="1">{
                c.LastName = lastName.(string)
        }</span>

        <span class="cov8" title="1">rl, ok := claims["roles"]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("could not parse claims roles")
        }</span>

        <span class="cov8" title="1">var roles []string
        if rl != nil </span><span class="cov8" title="1">{
                for _, v := range rl.([]any) </span><span class="cov8" title="1">{
                        roles = append(roles, v.(string))
                }</span>
        }
        <span class="cov8" title="1">c.Roles = roles

        // Parse permissions if they exist
        perms, ok := claims["permissions"]
        if ok &amp;&amp; perms != nil </span><span class="cov8" title="1">{
                var permissions []string
                for _, v := range perms.([]any) </span><span class="cov8" title="1">{
                        permissions = append(permissions, v.(string))
                }</span>
                <span class="cov8" title="1">c.Permissions = permissions</span>
        } else<span class="cov8" title="1"> {
                c.Permissions = []string{} // Initialize as empty array if not present
        }</span>

        // Parse static role flags
        <span class="cov8" title="1">isAdmin, ok := claims["is_admin"]
        if ok &amp;&amp; isAdmin != nil </span><span class="cov8" title="1">{
                c.IsAdmin = isAdmin.(bool)
        }</span>

        <span class="cov8" title="1">isTeacher, ok := claims["is_teacher"]
        if ok &amp;&amp; isTeacher != nil </span><span class="cov8" title="1">{
                c.IsTeacher = isTeacher.(bool)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RefreshClaims represents the claims parsed from JWT refresh token.
type RefreshClaims struct {
        ID    int    `json:"id,omitempty"`
        Token string `json:"token,omitempty"`
        CommonClaims
}

// ParseClaims parses the JWT claims into RefreshClaims.
func (c *RefreshClaims) ParseClaims(claims map[string]any) error <span class="cov8" title="1">{
        // Parse ID field
        id, ok := claims["id"]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("could not parse claim id")
        }</span>
        // Handle type assertion for numeric ID
        <span class="cov8" title="1">switch v := id.(type) </span>{
        case float64:<span class="cov8" title="1">
                c.ID = int(v)</span>
        case int:<span class="cov8" title="1">
                c.ID = v</span>
        case int64:<span class="cov8" title="1">
                c.ID = int(v)</span>
        default:<span class="cov8" title="1">
                return errors.New("invalid type for claim id")</span>
        }

        // Parse token field
        <span class="cov8" title="1">token, ok := claims["token"]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("could not parse claim token")
        }</span>
        <span class="cov8" title="1">c.Token = token.(string)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package jwt

import (
        "errors"
        "net/http"

        "github.com/go-chi/render"
)

// The list of jwt token errors presented to the end user.
var (
        ErrTokenUnauthorized   = errors.New("token unauthorized")
        ErrTokenExpired        = errors.New("token expired")
        ErrInvalidAccessToken  = errors.New("invalid access token")
        ErrInvalidRefreshToken = errors.New("invalid refresh token")
)

// ErrResponse renderer type for handling all sorts of errors.
type ErrResponse struct {
        Err            error `json:"-"` // low-level runtime error
        HTTPStatusCode int   `json:"-"` // http response status code

        StatusText string `json:"status"`          // user-level status message
        AppCode    int64  `json:"code,omitempty"`  // application-specific error code
        ErrorText  string `json:"error,omitempty"` // application-level error message, for debugging
}

// Render sets the application-specific error code in AppCode.
func (e *ErrResponse) Render(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        render.Status(r, e.HTTPStatusCode)
        return nil
}</span>

// ErrUnauthorized renders status 401 Unauthorized with custom error message.
func ErrUnauthorized(err error) render.Renderer <span class="cov8" title="1">{
        return &amp;ErrResponse{
                Err:            err,
                HTTPStatusCode: http.StatusUnauthorized,
                StatusText:     "error",
                ErrorText:      err.Error(),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package jwt

import (
        "time"

        "github.com/uptrace/bun"
)

// Token holds refresh jwt information.
type Token struct {
        ID        int       `bun:"id,pk,autoincrement" json:"id,omitempty"`
        CreatedAt time.Time `bun:"created_at,nullzero,notnull,default:current_timestamp" json:"created_at,omitempty"`
        UpdatedAt time.Time `bun:"updated_at,nullzero,notnull,default:current_timestamp" json:"updated_at,omitempty"`
        AccountID int       `bun:"account_id,notnull" json:"-"`

        Token      string    `bun:"token,notnull" json:"-"`
        Expiry     time.Time `bun:"expiry,notnull" json:"-"`
        Mobile     bool      `bun:"mobile,notnull" json:"mobile"`
        Identifier string    `bun:"identifier" json:"identifier,omitempty"`
}

// BeforeInsert hook executed before database insert operation.
func (t *Token) BeforeInsert(db *bun.DB) error <span class="cov8" title="1">{
        now := time.Now()
        if t.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                t.CreatedAt = now
                t.UpdatedAt = now
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BeforeUpdate hook executed before database update operation.
func (t *Token) BeforeUpdate(db *bun.DB) error <span class="cov8" title="1">{
        t.UpdatedAt = time.Now()
        return nil
}</span>

// Claims returns the token claims to be signed
func (t *Token) Claims() RefreshClaims <span class="cov8" title="1">{
        return RefreshClaims{
                ID:    t.ID,
                Token: t.Token,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package jwt

import (
        "crypto/rand"
        "encoding/json"
        "errors"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/go-chi/jwtauth/v5"
        "github.com/spf13/viper"
)

// TokenAuth implements JWT authentication flow.
type TokenAuth struct {
        JwtAuth          *jwtauth.JWTAuth
        JwtExpiry        time.Duration
        JwtRefreshExpiry time.Duration
}

// NewTokenAuth configures and returns a JWT authentication instance.
func NewTokenAuth() (*TokenAuth, error) <span class="cov8" title="1">{
        secret := viper.GetString("auth_jwt_secret")

        // Handle "random" secret setting with persistence
        if secret == "random" </span><span class="cov8" title="1">{
                // Check environment - don't allow random in production
                env := viper.GetString("app_env")
                if env == "production" </span><span class="cov8" title="1">{
                        return nil, errors.New("JWT secret cannot be 'random' in production")
                }</span>

                // For development, use a persistent secret file
                <span class="cov8" title="1">baseDir := viper.GetString("app_base_dir")
                if baseDir == "" </span><span class="cov8" title="1">{
                        // Default to current directory if not set
                        var err error
                        baseDir, err = os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                baseDir = "."
                        }</span>
                }

                // Store secret in a file within the project
                <span class="cov8" title="1">secretFile := filepath.Join(baseDir, ".jwt-dev-secret.key")
                secretBytes, err := os.ReadFile(secretFile)

                if err == nil &amp;&amp; len(secretBytes) &gt;= 32 </span><span class="cov8" title="1">{
                        // Use existing secret
                        secret = string(secretBytes)
                        log.Printf("Using persistent JWT secret from %s", secretFile)
                }</span> else<span class="cov8" title="1"> {
                        // Generate new secret
                        secret = randStringBytes(32)
                        log.Printf("Generated new JWT secret and saving to %s", secretFile)

                        // Save for future use
                        err = os.WriteFile(secretFile, []byte(secret), 0600)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Could not persist JWT secret: %v", err)
                        }</span>
                }
        }

        // Validate secret length/strength
        <span class="cov8" title="1">if len(secret) &lt; 32 </span><span class="cov8" title="1">{
                log.Printf("Warning: JWT secret is too short (%d chars). Recommend at least 32 chars.", len(secret))
        }</span>

        <span class="cov8" title="1">return NewTokenAuthWithSecret(secret)</span>
}

// NewTokenAuthWithSecret creates a TokenAuth with a specific secret
func NewTokenAuthWithSecret(secret string) (*TokenAuth, error) <span class="cov8" title="1">{
        a := &amp;TokenAuth{
                JwtAuth:          jwtauth.New("HS256", []byte(secret), nil),
                JwtExpiry:        viper.GetDuration("auth_jwt_expiry"),
                JwtRefreshExpiry: viper.GetDuration("auth_jwt_refresh_expiry"),
        }

        return a, nil
}</span>

// Default token auth instance for testing
var defaultTokenAuth *TokenAuth

// SetDefaultTokenAuth sets the default token auth for testing
func SetDefaultTokenAuth(auth *TokenAuth) <span class="cov8" title="1">{
        defaultTokenAuth = auth
}</span>

// GetDefaultTokenAuth gets the default token auth
func GetDefaultTokenAuth() (*TokenAuth, error) <span class="cov8" title="1">{
        if defaultTokenAuth != nil </span><span class="cov8" title="1">{
                return defaultTokenAuth, nil
        }</span>
        <span class="cov8" title="1">return NewTokenAuth()</span>
}

// Verifier http middleware will verify a jwt string from a http request.
func (a *TokenAuth) Verifier() func(http.Handler) http.Handler <span class="cov8" title="1">{
        return jwtauth.Verifier(a.JwtAuth)
}</span>

// GenTokenPair returns both an access token and a refresh token.
func (a *TokenAuth) GenTokenPair(accessClaims AppClaims, refreshClaims RefreshClaims) (string, string, error) <span class="cov8" title="1">{
        access, err := a.CreateJWT(accessClaims)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">refresh, err := a.CreateRefreshJWT(refreshClaims)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">return access, refresh, nil</span>
}

// CreateJWT returns an access token for provided account claims.
func (a *TokenAuth) CreateJWT(c AppClaims) (string, error) <span class="cov8" title="1">{
        c.IssuedAt = time.Now().Unix()
        c.ExpiresAt = time.Now().Add(a.JwtExpiry).Unix()

        claims, err := ParseStructToMap(c)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">_, tokenString, err := a.JwtAuth.Encode(claims)
        return tokenString, err</span>
}

func ParseStructToMap(c any) (map[string]any, error) <span class="cov8" title="1">{
        var claims map[string]any
        inrec, err := json.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(inrec, &amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Special handling for embedded structs like CommonClaims
        // This ensures all fields from embedded structs are properly included
        <span class="cov8" title="1">if appClaims, ok := c.(AppClaims); ok </span><span class="cov8" title="1">{
                // Make sure roles is explicitly set
                claims["roles"] = appClaims.Roles

                // Make sure permissions is explicitly set
                claims["permissions"] = appClaims.Permissions

                // Set common claims manually to ensure they're included
                claims["exp"] = appClaims.ExpiresAt
                claims["iat"] = appClaims.IssuedAt
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// CreateRefreshJWT returns a refresh token for provided token Claims.
func (a *TokenAuth) CreateRefreshJWT(c RefreshClaims) (string, error) <span class="cov8" title="1">{
        c.IssuedAt = time.Now().Unix()
        c.ExpiresAt = time.Now().Add(a.JwtRefreshExpiry).Unix()

        claims, err := ParseStructToMap(c)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">_, tokenString, err := a.JwtAuth.Encode(claims)
        return tokenString, err</span>
}

// GetRefreshExpiry returns the refresh token expiration duration
func (a *TokenAuth) GetRefreshExpiry() time.Duration <span class="cov8" title="1">{
        return a.JwtRefreshExpiry
}</span>

const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

func randStringBytes(n int) string <span class="cov8" title="1">{
        buf := make([]byte, n)
        if _, err := rand.Read(buf); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">for k, v := range buf </span><span class="cov8" title="1">{
                buf[k] = letterBytes[v%byte(len(letterBytes))]
        }</span>
        <span class="cov8" title="1">return string(buf)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
