services:
  server:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - 8080:8080
    volumes:
      # Mount source code for hot reload
      - ./backend:/app
      # Preserve go modules cache
      - go_mod_cache:/go/pkg/mod
    environment:
      TZ: ${TZ:-Europe/Berlin}
      LOG_LEVEL: ${LOG_LEVEL:-debug}
      LOG_TEXTLOGGING: ${LOG_TEXTLOGGING:-"true"}
      PORT: ${PORT:-8080}
      DB_DSN: ${DB_DSN:-postgres://postgres:${POSTGRES_PASSWORD}@postgres:5432/postgres?sslmode=require}
      DB_DEBUG: ${DB_DEBUG:-"true"}
      AUTH_JWT_SECRET: ${AUTH_JWT_SECRET}
      AUTH_JWT_EXPIRY: ${AUTH_JWT_EXPIRY:-15m}
      AUTH_JWT_REFRESH_EXPIRY: ${AUTH_JWT_REFRESH_EXPIRY:-24h}
      ADMIN_EMAIL: ${ADMIN_EMAIL:-admin@example.com}
      ADMIN_PASSWORD: ${ADMIN_PASSWORD}
      EMAIL_FROM_ADDRESS: ${EMAIL_FROM_ADDRESS:-"no-reply@example.com"}
      EMAIL_FROM_NAME: ${EMAIL_FROM_NAME:-"Project Phoenix"}
      EMAIL_SMTP_HOST: ${EMAIL_SMTP_HOST}
      EMAIL_SMTP_PORT: ${EMAIL_SMTP_PORT:-465}
      EMAIL_SMTP_USER: ${EMAIL_SMTP_USER}
      EMAIL_SMTP_PASSWORD: ${EMAIL_SMTP_PASSWORD}
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      INVITATION_TOKEN_EXPIRY_HOURS: ${INVITATION_TOKEN_EXPIRY_HOURS:-48}
      PASSWORD_RESET_TOKEN_EXPIRY_MINUTES: ${PASSWORD_RESET_TOKEN_EXPIRY_MINUTES:-30}
      ENABLE_CORS: ${ENABLE_CORS:-"true"}
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-}
      RATE_LIMIT_ENABLED: ${RATE_LIMIT_ENABLED:-"false"}
      RATE_LIMIT_REQUESTS_PER_MINUTE: ${RATE_LIMIT_REQUESTS_PER_MINUTE:-60}
      RATE_LIMIT_BURST: ${RATE_LIMIT_BURST:-10}
      RATE_LIMIT_AUTH_REQUESTS_PER_MINUTE: ${RATE_LIMIT_AUTH_REQUESTS_PER_MINUTE:-5}
      SECURITY_LOGGING_ENABLED: ${SECURITY_LOGGING_ENABLED:-"false"}
      CLEANUP_SCHEDULER_ENABLED: ${CLEANUP_SCHEDULER_ENABLED:-"true"}
      CLEANUP_SCHEDULER_TIME: ${CLEANUP_SCHEDULER_TIME:-"02:00"}
      CLEANUP_SCHEDULER_TIMEOUT_MINUTES: ${CLEANUP_SCHEDULER_TIMEOUT_MINUTES:-30}
      SESSION_END_SCHEDULER_ENABLED: ${SESSION_END_SCHEDULER_ENABLED:-"true"}
      SESSION_END_TIME: ${SESSION_END_TIME:-"18:00"}
      SESSION_END_TIMEOUT_MINUTES: ${SESSION_END_TIMEOUT_MINUTES:-10}
      STUDENT_DAILY_CHECKOUT_TIME: ${STUDENT_DAILY_CHECKOUT_TIME:-"15:00"}
      SESSION_CLEANUP_ENABLED: ${SESSION_CLEANUP_ENABLED:-"true"}
      SESSION_CLEANUP_INTERVAL_MINUTES: ${SESSION_CLEANUP_INTERVAL_MINUTES:-15}
      SESSION_ABANDONED_THRESHOLD_MINUTES: ${SESSION_ABANDONED_THRESHOLD_MINUTES:-60}
      OGS_DEVICE_PIN: ${OGS_DEVICE_PIN:-1234}
    # air handles the serve command via .air.toml
    networks:
      - default
      - internal  # For internal API access from betterauth

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
      args:
        BUILDKIT_INLINE_CACHE: 1
    ports:
      - "3000:3000"
    environment:
      TZ: ${TZ:-Europe/Berlin}
      AUTH_JWT_REFRESH_EXPIRY: ${AUTH_JWT_REFRESH_EXPIRY:-24h}
      # API URL for both client and server-side calls
      NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-"http://server:8080"}
      # NextAuth configuration
      NEXTAUTH_URL: ${NEXTAUTH_URL:-"http://localhost:3000"}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET}
      # BetterAuth service URL (internal Docker network)
      BETTERAUTH_INTERNAL_URL: ${BETTERAUTH_INTERNAL_URL:-http://betterauth:3001}
      # Skip env validation in Docker
      SKIP_ENV_VALIDATION: ${SKIP_ENV_VALIDATION:-"true"}
      NEXT_TELEMETRY_DISABLED: ${NEXT_TELEMETRY_DISABLED:-"1"}
    depends_on:
      - server
      - betterauth
    volumes:
      # Mount only source directories for hot reload
      - ./frontend/src:/app/src
      - ./frontend/public:/app/public
      # Mount config files that might change
      - ./frontend/package.json:/app/package.json
      - ./frontend/pnpm-lock.yaml:/app/pnpm-lock.yaml
      - ./frontend/next.config.js:/app/next.config.js
      - ./frontend/tsconfig.json:/app/tsconfig.json
      - ./frontend/tailwind.config.js:/app/tailwind.config.js
      - ./frontend/postcss.config.js:/app/postcss.config.js
      # Use named volume for node_modules to avoid conflicts
      - frontend_node_modules:/app/node_modules
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # BetterAuth authentication service for multi-tenancy
  # Handles user authentication, sessions, and organization management
  betterauth:
    build:
      context: ./betterauth
      dockerfile: Dockerfile
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "3001:3001"
    environment:
      TZ: ${TZ:-Europe/Berlin}
      DATABASE_URL: postgres://postgres:${POSTGRES_PASSWORD}@postgres:5432/postgres?sslmode=require
      BETTER_AUTH_SECRET: ${BETTER_AUTH_SECRET:-change-me-in-production-min-32-chars}
      BETTER_AUTH_URL: http://localhost:3001
      TRUSTED_ORIGINS: http://localhost:3000,http://localhost:8080
      PORT: 3001
      # Internal API URL for org lifecycle emails (Docker internal network)
      INTERNAL_API_URL: ${INTERNAL_API_URL:-http://server:8080}
      # Allow self-signed SSL certificates in development
      # In production, use proper SSL certificates
      NODE_TLS_REJECT_UNAUTHORIZED: "0"
    networks:
      - default
      - internal  # For internal API access to Go backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  postgres:
    image: postgres:17
    restart: unless-stopped
    ports:
      - 5432:5432
    volumes:
      - postgres:/var/lib/postgresql/data
      - ./config/ssl/postgres/certs/server.crt:/var/lib/postgresql/ssl/server.crt:ro
      - ./config/ssl/postgres/certs/server.key:/var/lib/postgresql/ssl/server.key:ro
      - ./config/ssl/postgres/certs/ca.crt:/var/lib/postgresql/ssl/ca.crt:ro
      - ./config/ssl/postgres/postgresql.conf:/etc/postgresql/postgresql.conf:ro
      - ./config/ssl/postgres/pg_hba.conf:/etc/postgresql/pg_hba.conf:ro
    environment:
      TZ: ${TZ:-Europe/Berlin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    command:
      [
        "-c",
        "config_file=/etc/postgresql/postgresql.conf",
        "-c",
        "hba_file=/etc/postgresql/pg_hba.conf",
      ]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 1s
      timeout: 1s
      retries: 2

  # Test database for integration tests
  # Start with: docker compose --profile test up -d postgres-test
  # Or run all tests: docker compose --profile test up -d
  postgres-test:
    image: postgres:17
    profiles: ["test"]
    restart: unless-stopped
    ports:
      - "${TEST_DB_PORT:-5433}:5432"
    volumes:
      - postgres_test:/var/lib/postgresql/data
    environment:
      TZ: ${TZ:-Europe/Berlin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DB: phoenix_test
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d phoenix_test"]
      interval: 1s
      timeout: 1s
      retries: 5

networks:
  # Default external network - accessible from host
  default:
    driver: bridge
  # Internal network - for internal API communication only
  internal:
    driver: bridge
    internal: true  # Not accessible from host

volumes:
  postgres:
  postgres_test:
  frontend_node_modules:
  go_mod_cache:
